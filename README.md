# АСПЗ

## Практична робота №2, Варіант 8

### 2.1 — Переповнення `time_t`

Програма визначає розмір типу `time_t` і:
- Якщо 32 біти — обчислює момент переповнення;
- Якщо 64 біти — виводить повідомлення про відсутність переповнення.

#### Скріншот:
![time_t](https://github.com/KostyaKindaluk/practice-2/blob/master/task1/screenshot.png)

---

### 2.2 — Сегменти виконуваного файлу

#### Кроки:
1. Скомпільовано `Hello World`;
2. Проаналізовано сегменти (`.text`, `.data`, `.bss`) за допомогою `size` та `ls -l`;
3. Додано:
   - глобальний масив `int[1000]`,
   - ініціалізацію цього масиву,
   - локальні масиви (з ініціалізацією та без),
   - флаг `-g` (debug) та `-O2` (оптимізація).

#### Висновки:
- `.bss` не зберігається у виконуваному файлі;
- `.data` — зберігається;
- `.text` — зменшується при оптимізації;
- Файл з `-g` більший.

#### Скріншоти:
![1](https://github.com/KostyaKindaluk/practice-2/blob/master/task2/screenshot1.png)
![2](https://github.com/KostyaKindaluk/practice-2/blob/master/task2/screenshot2.png)
![3](https://github.com/KostyaKindaluk/practice-2/blob/master/task2/screenshot3.png)
![4](https://github.com/KostyaKindaluk/practice-2/blob/master/task2/screenshot4.png)
![5](https://github.com/KostyaKindaluk/practice-2/blob/master/task2/screenshot5.png)

---

### 2.3 — Сегменти пам’яті

Програма виводить адреси:
- локальних змінних (у стеку),
- глобальних змінних (у `.data`/`.bss`),
- функцій (у `.text`),
- локального масиву з іншої функції — демонструє зміну адреси при новому виклику.

#### Скріншот:
![memory segments](https://github.com/KostyaKindaluk/practice-2/blob/master/task3/screenshot.png)

---

### 2.4 — Порівняння `gstack` і `gdb`

#### `gstack`:
- Простий інструмент для швидкого перегляду стеку.

#### `gdb`:
- Дає повну інформацію: покрокове виконання, перегляд і зміна змінних, регістрів тощо.

#### Скріншот:
![gdb](https://github.com/KostyaKindaluk/practice-2/blob/master/task4/screenshot.png)

---

### 2.5 — Чи можна замінити IP стеком?

- Ні. Лічильник команд (**Instruction Pointer**) визначає наступну інструкцію для виконання.
- Стек лише зберігає адреси повернення та змінні, але **не може** сам керувати потоком виконання.

---

## Варіант 8 — Експлойт для переповнення буфера

### Умова  
Реалізуйте експлойт для переповнення буфера у програмі з вразливою функцією, що використовує `gets()` для зчитування даних у локальний буфер.

---

### Опис рішення

У програмі створено функцію `vulnerable_function()`, яка оголошує локальний буфер розміром 64 байти і читає в нього дані за допомогою небезпечної функції `gets()`. Це дозволяє ввести рядок, довший за розмір буфера, що призводить до переповнення і потенційного зміщення даних у стеку (наприклад, адреси повернення).

Для демонстрації експлойту можна підготувати спеціальний вхідний рядок, який перезаписує адресу повернення функції та направляє виконання на шкідливий код або іншу частину програми.

---

#### Скріншот:
![exploit](https://github.com/KostyaKindaluk/practice-2/blob/master/variant8/screenshot.png)
